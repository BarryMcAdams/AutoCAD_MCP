"""
Template Manager for Master AutoCAD Coder.

Manages code templates for Python, AutoLISP, and VBA generation.
Provides template discovery, customization, and management capabilities.
"""

from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from pathlib import Path
import json
import re
from datetime import datetime


@dataclass
class CodeTemplate:
    """Represents a code template."""
    id: str
    name: str
    language: str  # python, autolisp, vba
    category: str  # drawing, data_processing, automation, etc.
    description: str
    author: str
    version: str
    created_date: str
    template_code: str
    parameters: List[str]
    dependencies: List[str]
    examples: List[str]
    tags: List[str]
    complexity: str  # basic, intermediate, advanced
    usage_instructions: List[str]


@dataclass
class TemplateCategory:
    """Represents a template category."""
    name: str
    description: str
    languages: List[str]
    templates: List[str]  # Template IDs


class TemplateManager:
    """Manages code generation templates across all languages."""
    
    def __init__(self, templates_directory: Optional[str] = None):
        self.templates_dir = Path(templates_directory) if templates_directory else Path("templates")
        self.templates: Dict[str, CodeTemplate] = {}
        self.categories: Dict[str, TemplateCategory] = {}
        self._initialize_default_templates()
        self._initialize_categories()
    
    def _initialize_default_templates(self):
        """Initialize default templates for all languages."""
        # Python templates
        self._add_python_templates()
        # AutoLISP templates  
        self._add_autolisp_templates()
        # VBA templates
        self._add_vba_templates()
    
    def _add_python_templates(self):
        """Add default Python templates."""
        
        # Basic drawing template
        self.templates["python_basic_drawing"] = CodeTemplate(
            id="python_basic_drawing",
            name="Basic AutoCAD Drawing",
            language="python",
            category="drawing",
            description="Basic Python script for AutoCAD drawing operations",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code="""#!/usr/bin/env python3
\"\"\"
{description}
Generated by Master AutoCAD Coder
\"\"\"

from src.enhanced_autocad.compatibility_layer import Autocad
import logging

def main():
    \"\"\"Main execution function.\"\"\"
    # Initialize AutoCAD connection
    acad = Autocad()
    
    if not acad.get_connection_status()['connected']:
        logging.error("Failed to connect to AutoCAD")
        return False
    
    try:
        {drawing_operations}
        
        logging.info("Drawing operations completed successfully")
        return True
        
    except Exception as e:
        logging.error(f"Error: {{e}}")
        return False

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    success = main()
    print(f"Operation {{'completed' if success else 'failed'}}")""",
            parameters=["description", "drawing_operations"],
            dependencies=["enhanced_autocad"],
            examples=[
                "python basic_drawing.py",
                "Drawing lines and circles in AutoCAD"
            ],
            tags=["python", "drawing", "basic", "autocad"],
            complexity="basic",
            usage_instructions=[
                "Replace {drawing_operations} with your drawing code",
                "Ensure AutoCAD is running before execution",
                "Run with: python script_name.py"
            ]
        )
        
        # Data processing template
        self.templates["python_data_processing"] = CodeTemplate(
            id="python_data_processing",
            name="Data Processing with AutoCAD",
            language="python",
            category="data_processing",
            description="Process external data and create AutoCAD entities",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code="""#!/usr/bin/env python3
\"\"\"
{description}
Data processing and AutoCAD integration
\"\"\"

from src.enhanced_autocad.compatibility_layer import Autocad
import pandas as pd
import logging
from pathlib import Path

def load_data(file_path: str) -> pd.DataFrame:
    \"\"\"Load data from file.\"\"\"
    if file_path.endswith('.csv'):
        return pd.read_csv(file_path)
    elif file_path.endswith(('.xlsx', '.xls')):
        return pd.read_excel(file_path)
    else:
        raise ValueError(f"Unsupported file format: {{file_path}}")

def process_data(df: pd.DataFrame) -> pd.DataFrame:
    \"\"\"Process and transform data.\"\"\"
    {data_processing}
    return df

def create_entities(acad: Autocad, df: pd.DataFrame):
    \"\"\"Create AutoCAD entities from data.\"\"\"
    for _, row in df.iterrows():
        {entity_creation}

def main():
    \"\"\"Main execution function.\"\"\"
    # Initialize AutoCAD
    acad = Autocad()
    if not acad.get_connection_status()['connected']:
        logging.error("AutoCAD not connected")
        return False
    
    # Load and process data
    data_file = "{data_file_path}"
    df = load_data(data_file)
    processed_df = process_data(df)
    
    # Create entities
    create_entities(acad, processed_df)
    
    logging.info(f"Processed {{len(processed_df)}} records")
    return True

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    success = main()""",
            parameters=["description", "data_processing", "entity_creation", "data_file_path"],
            dependencies=["enhanced_autocad", "pandas"],
            examples=[
                "Processing CSV data to create AutoCAD lines",
                "Excel to AutoCAD entity conversion"
            ],
            tags=["python", "data", "processing", "excel", "csv"],
            complexity="intermediate",
            usage_instructions=[
                "Install pandas: pip install pandas",
                "Update data_file_path with your data file",
                "Customize data_processing and entity_creation sections"
            ]
        )
        
        # Batch processing template
        self.templates["python_batch_processing"] = CodeTemplate(
            id="python_batch_processing",
            name="Batch Processing Framework",
            language="python",
            category="automation",
            description="Framework for batch processing multiple items",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code="""#!/usr/bin/env python3
\"\"\"
{description}
Batch processing framework for AutoCAD automation
\"\"\"

from src.enhanced_autocad.compatibility_layer import Autocad
from concurrent.futures import ThreadPoolExecutor
import logging
from typing import List, Any, Dict

class BatchProcessor:
    \"\"\"Handles batch processing operations.\"\"\"
    
    def __init__(self, max_workers: int = 4):
        self.acad = None
        self.max_workers = max_workers
        self.results = []
    
    def initialize_autocad(self) -> bool:
        \"\"\"Initialize AutoCAD connection.\"\"\"
        self.acad = Autocad()
        return self.acad.get_connection_status()['connected']
    
    def process_item(self, item: Any) -> Dict[str, Any]:
        \"\"\"Process a single item.\"\"\"
        try:
            {item_processing}
            return {{"success": True, "item": str(item)}}
        except Exception as e:
            return {{"success": False, "item": str(item), "error": str(e)}}
    
    def process_batch(self, items: List[Any]) -> List[Dict[str, Any]]:
        \"\"\"Process multiple items.\"\"\"
        logging.info(f"Processing {{len(items)}} items")
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            results = list(executor.map(self.process_item, items))
        
        return results

def main():
    \"\"\"Main execution function.\"\"\"
    processor = BatchProcessor()
    
    if not processor.initialize_autocad():
        return False
    
    # Define items to process
    items = {batch_items}
    
    # Process batch
    results = processor.process_batch(items)
    
    # Report results
    successful = sum(1 for r in results if r['success'])
    logging.info(f"Completed: {{successful}}/{{len(results)}}")
    
    return successful == len(results)

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    success = main()""",
            parameters=["description", "item_processing", "batch_items"],
            dependencies=["enhanced_autocad"],
            examples=[
                "Batch process multiple drawing files",
                "Process list of coordinates for entity creation"
            ],
            tags=["python", "batch", "parallel", "automation"],
            complexity="advanced",
            usage_instructions=[
                "Define items to process in batch_items",
                "Implement item_processing logic for single items",
                "Adjust max_workers based on system capabilities"
            ]
        )
    
    def _add_autolisp_templates(self):
        """Add default AutoLISP templates."""
        
        # Basic command template
        self.templates["autolisp_basic_command"] = CodeTemplate(
            id="autolisp_basic_command",
            name="Basic AutoLISP Command",
            language="autolisp",
            category="drawing",
            description="Basic AutoLISP command template",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code="""(defun c:{command_name} ( / {local_vars})
  ;; {description}
  ;; Generated by Master AutoCAD Coder
  
  {command_body}
  
  (princ)
)

;; Load message
(princ "\\n{command_name} command loaded. Type '{command_name}' to execute.")
(princ)""",
            parameters=["command_name", "description", "local_vars", "command_body"],
            dependencies=["AutoCAD"],
            examples=[
                "(c:drawline)",
                "(c:mycircle)"
            ],
            tags=["autolisp", "command", "basic"],
            complexity="basic",
            usage_instructions=[
                "Load using APPLOAD command in AutoCAD",
                "Type command name at AutoCAD command prompt",
                "Modify local_vars and command_body as needed"
            ]
        )
        
        # Drawing utilities template
        self.templates["autolisp_drawing_utilities"] = CodeTemplate(
            id="autolisp_drawing_utilities",
            name="Drawing Utilities Collection",
            language="autolisp",
            category="utilities",
            description="Collection of useful drawing utility functions",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code=""";;; Drawing Utilities
;;; {description}
;;; Generated by Master AutoCAD Coder

;; Get point with prompt
(defun get-point-safe (prompt / pt)
  (setq pt (getpoint prompt))
  (if pt pt nil)
)

;; Get distance with prompt
(defun get-distance-safe (prompt base-pt / dist)
  (setq dist (getdist base-pt prompt))
  (if dist dist nil)
)

;; Create line with error checking
(defun create-line-safe (pt1 pt2 / line-obj)
  (if (and pt1 pt2)
    (progn
      (setq line-obj (entmake (list '(0 . "LINE") (cons 10 pt1) (cons 11 pt2))))
      (if line-obj
        (progn
          (princ "\\nLine created successfully.")
          line-obj
        )
        (progn
          (princ "\\nError creating line.")
          nil
        )
      )
    )
    (progn
      (princ "\\nInvalid points provided.")
      nil
    )
  )
)

;; Create circle with error checking  
(defun create-circle-safe (center radius / circle-obj)
  (if (and center radius (> radius 0))
    (progn
      (setq circle-obj (entmake (list '(0 . "CIRCLE") (cons 10 center) (cons 40 radius))))
      (if circle-obj
        (progn
          (princ "\\nCircle created successfully.")
          circle-obj
        )
        (progn
          (princ "\\nError creating circle.")
          nil
        )
      )
    )
    (progn
      (princ "\\nInvalid center point or radius.")
      nil
    )
  )
)

{additional_utilities}

;; Load message
(princ "\\nDrawing utilities loaded.")
(princ)""",
            parameters=["description", "additional_utilities"],
            dependencies=["AutoCAD"],
            examples=[
                "(create-line-safe '(0 0 0) '(100 100 0))",
                "(create-circle-safe '(50 50 0) 25)"
            ],
            tags=["autolisp", "utilities", "drawing", "functions"],
            complexity="intermediate",
            usage_instructions=[
                "Load into AutoCAD using APPLOAD",
                "Use individual functions in other LISP routines",
                "Add custom utilities in additional_utilities section"
            ]
        )
        
        # Selection processing template
        self.templates["autolisp_selection_processing"] = CodeTemplate(
            id="autolisp_selection_processing",
            name="Selection Processing Framework",
            language="autolisp",
            category="automation",
            description="Framework for processing selected entities",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code="""(defun c:{command_name} ( / ss i ent ent-data count processed)
  ;; {description}
  ;; Generated by Master AutoCAD Coder
  
  (princ "\\nSelect entities to process: ")
  (setq ss (ssget))
  (setq processed 0)
  
  (if ss
    (progn
      (setq count (sslength ss))
      (princ (strcat "\\nProcessing " (itoa count) " entities..."))
      
      ;; Process each entity
      (setq i 0)
      (repeat count
        (setq ent (ssname ss i))
        (setq ent-data (entget ent))
        
        (if (process-entity ent ent-data)
          (setq processed (1+ processed))
        )
        
        ;; Progress indicator
        (if (= (rem (1+ i) 10) 0)
          (princ (strcat "\\nProcessed " (itoa (1+ i)) " of " (itoa count) "..."))
        )
        
        (setq i (1+ i))
      )
      
      (princ (strcat "\\nCompleted. Successfully processed " 
                     (itoa processed) " of " (itoa count) " entities."))
    )
    (princ "\\nNo entities selected.")
  )
  (princ)
)

;; Process individual entity
(defun process-entity (ent ent-data / entity-type result)
  ;; Get entity type
  (setq entity-type (cdr (assoc 0 ent-data)))
  
  ;; Process based on entity type
  (cond
    ((= entity-type "LINE")
     {line_processing}
    )
    ((= entity-type "CIRCLE")
     {circle_processing}
    )
    ((= entity-type "POLYLINE")
     {polyline_processing}
    )
    (T
     ;; Default processing for other entities
     {default_processing}
    )
  )
)

;; Load message
(princ "\\n{command_name} command loaded.")
(princ)""",
            parameters=["command_name", "description", "line_processing", "circle_processing", "polyline_processing", "default_processing"],
            dependencies=["AutoCAD"],
            examples=[
                "Processing all selected lines",
                "Batch modify entity properties"
            ],
            tags=["autolisp", "selection", "batch", "processing"],
            complexity="advanced",
            usage_instructions=[
                "Customize processing functions for each entity type",
                "Load with APPLOAD and run command",
                "Modify progress indicators as needed"
            ]
        )
    
    def _add_vba_templates(self):
        """Add default VBA templates."""
        
        # Basic macro template
        self.templates["vba_basic_macro"] = CodeTemplate(
            id="vba_basic_macro",
            name="Basic VBA Macro",
            language="vba",
            category="automation",
            description="Basic VBA macro template for AutoCAD",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code="""' {macro_name}
' {description}
' Generated by Master AutoCAD Coder

Option Explicit

Sub {macro_name}()
    On Error GoTo ErrorHandler
    
    Dim acadApp As AcadApplication
    Dim acadDoc As AcadDocument
    
    ' Connect to AutoCAD
    Set acadApp = GetObject(, "AutoCAD.Application")
    Set acadDoc = acadApp.ActiveDocument
    
    {macro_body}
    
    MsgBox "Macro completed successfully!"
    Exit Sub
    
ErrorHandler:
    MsgBox "Error in {macro_name}: " & Err.Description
End Sub""",
            parameters=["macro_name", "description", "macro_body"],
            dependencies=["AutoCAD Type Library"],
            examples=[
                "Drawing basic entities",
                "Modifying drawing properties"
            ],
            tags=["vba", "macro", "basic", "autocad"],
            complexity="basic",
            usage_instructions=[
                "Open AutoCAD VBA Editor (Alt+F11)",
                "Insert new module and paste code",
                "Add reference to AutoCAD Type Library",
                "Run macro from VBA Editor or AutoCAD"
            ]
        )
        
        # Excel integration template
        self.templates["vba_excel_integration"] = CodeTemplate(
            id="vba_excel_integration",
            name="Excel Integration",
            language="vba",
            category="data_processing",
            description="VBA template for Excel and AutoCAD integration",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code="""' Excel Integration Macro
' {description}
' Generated by Master AutoCAD Coder

Option Explicit

Sub {macro_name}()
    On Error GoTo ErrorHandler
    
    Dim acadApp As AcadApplication
    Dim acadDoc As AcadDocument
    Dim xlApp As Object
    Dim xlWorkbook As Object
    Dim xlWorksheet As Object
    
    ' Connect to AutoCAD
    Set acadApp = GetObject(, "AutoCAD.Application")
    Set acadDoc = acadApp.ActiveDocument
    
    ' Connect to Excel
    Set xlApp = CreateObject("Excel.Application")
    xlApp.Visible = True
    
    {excel_operations}
    
    ' Cleanup
    Set xlWorksheet = Nothing
    Set xlWorkbook = Nothing
    xlApp.Quit
    Set xlApp = Nothing
    
    MsgBox "Excel integration completed!"
    Exit Sub
    
ErrorHandler:
    MsgBox "Error: " & Err.Description
    ' Cleanup on error
    If Not xlApp Is Nothing Then
        xlApp.Quit
        Set xlApp = Nothing
    End If
End Sub""",
            parameters=["macro_name", "description", "excel_operations"],
            dependencies=["AutoCAD Type Library", "Microsoft Excel Object Library"],
            examples=[
                "Import coordinates from Excel",
                "Export entity data to Excel"
            ],
            tags=["vba", "excel", "integration", "data"],
            complexity="intermediate",
            usage_instructions=[
                "Add references to both AutoCAD and Excel libraries",
                "Customize excel_operations section",
                "Ensure Excel is installed on the system"
            ]
        )
        
        # User form template
        self.templates["vba_user_form"] = CodeTemplate(
            id="vba_user_form",
            name="User Interface Form",
            language="vba",
            category="ui",
            description="VBA UserForm template for user interaction",
            author="Master AutoCAD Coder",
            version="1.0",
            created_date=datetime.now().isoformat(),
            template_code="""' {form_name} UserForm
' {description}
' Generated by Master AutoCAD Coder

Option Explicit

' Form initialization
Private Sub UserForm_Initialize()
    Me.Caption = "{form_title}"
    InitializeControls
End Sub

' Initialize form controls
Private Sub InitializeControls()
    {control_initialization}
End Sub

' OK button click event
Private Sub cmdOK_Click()
    On Error GoTo ErrorHandler
    
    ' Validate input
    If ValidateInput() Then
        ProcessInput
        Me.Hide
    End If
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error processing input: " & Err.Description
End Sub

' Cancel button click event
Private Sub cmdCancel_Click()
    Me.Hide
End Sub

' Validate user input
Private Function ValidateInput() As Boolean
    {input_validation}
    ValidateInput = True
End Function

' Process form input
Private Sub ProcessInput()
    On Error GoTo ErrorHandler
    
    Dim acadApp As AcadApplication
    Dim acadDoc As AcadDocument
    
    ' Connect to AutoCAD
    Set acadApp = GetObject(, "AutoCAD.Application")
    Set acadDoc = acadApp.ActiveDocument
    
    {form_processing}
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error in form processing: " & Err.Description
End Sub""",
            parameters=["form_name", "description", "form_title", "control_initialization", "input_validation", "form_processing"],
            dependencies=["AutoCAD Type Library"],
            examples=[
                "Input form for drawing parameters",
                "Settings configuration dialog"
            ],
            tags=["vba", "userform", "ui", "dialog"],
            complexity="advanced",
            usage_instructions=[
                "Insert UserForm in VBA Editor",
                "Add controls (buttons, text boxes, etc.)",
                "Replace form code with this template",
                "Customize control initialization and processing"
            ]
        )
    
    def _initialize_categories(self):
        """Initialize template categories."""
        self.categories = {
            "drawing": TemplateCategory(
                name="Drawing Operations",
                description="Templates for creating and manipulating drawing entities",
                languages=["python", "autolisp", "vba"],
                templates=["python_basic_drawing", "autolisp_basic_command", "vba_basic_macro"]
            ),
            "data_processing": TemplateCategory(
                name="Data Processing",
                description="Templates for data import, export, and processing",
                languages=["python", "vba"],
                templates=["python_data_processing", "vba_excel_integration"]
            ),
            "automation": TemplateCategory(
                name="Automation & Batch Processing",
                description="Templates for automated workflows and batch operations",
                languages=["python", "autolisp", "vba"],
                templates=["python_batch_processing", "autolisp_selection_processing"]
            ),
            "utilities": TemplateCategory(
                name="Utilities & Libraries",
                description="Reusable utility functions and libraries",
                languages=["autolisp"],
                templates=["autolisp_drawing_utilities"]
            ),
            "ui": TemplateCategory(
                name="User Interface",
                description="Templates for user interaction and forms",
                languages=["vba"],
                templates=["vba_user_form"]
            )
        }
    
    def get_template(self, template_id: str) -> Optional[CodeTemplate]:
        """Get a template by ID."""
        return self.templates.get(template_id)
    
    def get_templates_by_language(self, language: str) -> List[CodeTemplate]:
        """Get all templates for a specific language."""
        return [template for template in self.templates.values() if template.language == language]
    
    def get_templates_by_category(self, category: str) -> List[CodeTemplate]:
        """Get all templates in a specific category."""
        return [template for template in self.templates.values() if template.category == category]
    
    def get_templates_by_complexity(self, complexity: str) -> List[CodeTemplate]:
        """Get all templates of a specific complexity level."""
        return [template for template in self.templates.values() if template.complexity == complexity]
    
    def search_templates(self, query: str) -> List[CodeTemplate]:
        """Search templates by query string."""
        query_lower = query.lower()
        results = []
        
        for template in self.templates.values():
            # Search in name, description, and tags
            if (query_lower in template.name.lower() or
                query_lower in template.description.lower() or
                any(query_lower in tag.lower() for tag in template.tags)):
                results.append(template)
        
        return results
    
    def create_custom_template(self, template_data: Dict[str, Any]) -> str:
        """Create a custom template and return its ID."""
        template_id = f"custom_{template_data.get('language', 'unknown')}_{len(self.templates)}"
        
        template = CodeTemplate(
            id=template_id,
            name=template_data.get('name', 'Custom Template'),
            language=template_data.get('language', 'python'),
            category=template_data.get('category', 'custom'),
            description=template_data.get('description', 'Custom user template'),
            author=template_data.get('author', 'User'),
            version=template_data.get('version', '1.0'),
            created_date=datetime.now().isoformat(),
            template_code=template_data.get('template_code', ''),
            parameters=template_data.get('parameters', []),
            dependencies=template_data.get('dependencies', []),
            examples=template_data.get('examples', []),
            tags=template_data.get('tags', ['custom']),
            complexity=template_data.get('complexity', 'basic'),
            usage_instructions=template_data.get('usage_instructions', [])
        )
        
        self.templates[template_id] = template
        return template_id
    
    def render_template(self, template_id: str, parameters: Dict[str, Any]) -> Optional[str]:
        """Render a template with the provided parameters."""
        template = self.get_template(template_id)
        if not template:
            return None
        
        try:
            # Replace parameters in template code
            rendered_code = template.template_code
            for param_name, param_value in parameters.items():
                placeholder = "{" + param_name + "}"
                rendered_code = rendered_code.replace(placeholder, str(param_value))
            
            return rendered_code
        except Exception as e:
            return f"Error rendering template: {str(e)}"
    
    def validate_template_parameters(self, template_id: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Validate parameters for a template."""
        template = self.get_template(template_id)
        if not template:
            return {"valid": False, "error": "Template not found"}
        
        missing_params = []
        for required_param in template.parameters:
            if required_param not in parameters:
                missing_params.append(required_param)
        
        return {
            "valid": len(missing_params) == 0,
            "missing_parameters": missing_params,
            "required_parameters": template.parameters,
            "provided_parameters": list(parameters.keys())
        }
    
    def get_template_suggestions(self, description: str, language: Optional[str] = None) -> List[CodeTemplate]:
        """Get template suggestions based on description."""
        suggestions = []
        desc_lower = description.lower()
        
        # Score templates based on relevance
        for template in self.templates.values():
            if language and template.language != language:
                continue
            
            score = 0
            
            # Check description keywords
            if any(word in desc_lower for word in template.description.lower().split()):
                score += 2
            
            # Check tags
            for tag in template.tags:
                if tag.lower() in desc_lower:
                    score += 1
            
            # Check category
            if template.category.lower() in desc_lower:
                score += 1
            
            if score > 0:
                suggestions.append((template, score))
        
        # Sort by score and return templates
        suggestions.sort(key=lambda x: x[1], reverse=True)
        return [template for template, score in suggestions[:5]]  # Top 5 suggestions
    
    def export_template(self, template_id: str) -> Optional[Dict[str, Any]]:
        """Export a template to a dictionary."""
        template = self.get_template(template_id)
        if not template:
            return None
        
        return asdict(template)
    
    def import_template(self, template_data: Dict[str, Any]) -> str:
        """Import a template from dictionary data."""
        template = CodeTemplate(**template_data)
        self.templates[template.id] = template
        return template.id
    
    def save_templates_to_file(self, file_path: str):
        """Save all templates to a JSON file."""
        templates_data = {
            template_id: asdict(template) 
            for template_id, template in self.templates.items()
        }
        
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(templates_data, f, indent=2, ensure_ascii=False)
    
    def load_templates_from_file(self, file_path: str):
        """Load templates from a JSON file."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                templates_data = json.load(f)
            
            for template_id, template_data in templates_data.items():
                template = CodeTemplate(**template_data)
                self.templates[template_id] = template
                
        except Exception as e:
            raise Exception(f"Failed to load templates: {str(e)}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get template statistics."""
        languages = {}
        categories = {}
        complexities = {}
        
        for template in self.templates.values():
            # Count by language
            languages[template.language] = languages.get(template.language, 0) + 1
            
            # Count by category
            categories[template.category] = categories.get(template.category, 0) + 1
            
            # Count by complexity
            complexities[template.complexity] = complexities.get(template.complexity, 0) + 1
        
        return {
            "total_templates": len(self.templates),
            "languages": languages,
            "categories": categories,
            "complexities": complexities,
            "available_categories": list(self.categories.keys())
        }
    
    def list_all_templates(self) -> List[Dict[str, Any]]:
        """List all templates with basic information."""
        return [
            {
                "id": template.id,
                "name": template.name,
                "language": template.language,
                "category": template.category,
                "complexity": template.complexity,
                "description": template.description,
                "tags": template.tags
            }
            for template in self.templates.values()
        ]
    
    def clone_template(self, template_id: str, new_name: str, modifications: Dict[str, Any] = None) -> str:
        """Clone an existing template with optional modifications."""
        original = self.get_template(template_id)
        if not original:
            raise ValueError(f"Template {template_id} not found")
        
        # Create new template ID
        new_id = f"clone_{template_id}_{len(self.templates)}"
        
        # Create cloned template
        cloned_data = asdict(original)
        cloned_data['id'] = new_id
        cloned_data['name'] = new_name
        cloned_data['created_date'] = datetime.now().isoformat()
        cloned_data['version'] = '1.0'
        
        # Apply modifications
        if modifications:
            cloned_data.update(modifications)
        
        cloned_template = CodeTemplate(**cloned_data)
        self.templates[new_id] = cloned_template
        
        return new_id
    
    def delete_template(self, template_id: str) -> bool:
        """Delete a template."""
        if template_id in self.templates:
            del self.templates[template_id]
            return True
        return False