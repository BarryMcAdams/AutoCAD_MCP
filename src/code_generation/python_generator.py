"""
Python Script Generator for Master AutoCAD Coder.

Generates Python code for AutoCAD automation using the enhanced wrapper.
Leverages object inspection and best practices for professional development.
"""

import re
from dataclasses import dataclass
from typing import Any


@dataclass
class PythonTemplate:
    """Represents a Python code template."""

    name: str
    description: str
    parameters: list[str]
    imports: list[str]
    code_template: str
    usage_example: str


class PythonGenerator:
    """Generates Python code for AutoCAD automation tasks."""

    def __init__(self):
        self.templates = self._initialize_templates()
        self.patterns = self._initialize_patterns()
        self.common_imports = self._initialize_imports()

    def _initialize_imports(self) -> dict[str, list[str]]:
        """Initialize common import patterns."""
        return {
            "basic": [
                "from src.enhanced_autocad.compatibility_layer import Autocad",
                "import logging",
            ],
            "advanced": [
                "from src.enhanced_autocad.compatibility_layer import Autocad",
                "from src.enhanced_autocad.error_handler import handle_autocad_errors",
                "from src.enhanced_autocad.performance_monitor import monitor_performance",
                "import logging",
                "from typing import List, Dict, Any, Optional, Tuple",
            ],
            "data_processing": [
                "from src.enhanced_autocad.compatibility_layer import Autocad",
                "import pandas as pd",
                "import numpy as np",
                "import json",
                "import csv",
                "from pathlib import Path",
                "import logging",
            ],
            "batch_processing": [
                "from src.enhanced_autocad.compatibility_layer import Autocad",
                "from pathlib import Path",
                "import os",
                "import logging",
                "from concurrent.futures import ThreadPoolExecutor",
                "from typing import List, Dict, Any",
            ],
            "excel_integration": [
                "from src.enhanced_autocad.compatibility_layer import Autocad",
                "import pandas as pd",
                "import openpyxl",
                "from pathlib import Path",
                "import logging",
            ],
        }

    def _initialize_templates(self) -> dict[str, PythonTemplate]:
        """Initialize Python code templates."""
        return {
            "basic_drawing": PythonTemplate(
                name="basic_drawing",
                description="Basic drawing operations with enhanced AutoCAD wrapper",
                parameters=["operation_type", "coordinates", "properties"],
                imports=["basic"],
                code_template="""#!/usr/bin/env python3
\"\"\"
{description}
Generated by Master AutoCAD Coder
\"\"\"

{imports}

def main():
    \"\"\"Main execution function.\"\"\"
    # Initialize enhanced AutoCAD connection
    acad = Autocad()
    # Verify connection
    if not acad.get_connection_status()['connected']:
        logging.error("Failed to connect to AutoCAD")
        return False
    try:
        # {operation_description}
        {main_code}
        logging.info("Drawing operation completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during drawing operation: {{e}}")
        return False

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    success = main()
    print("Operation " + ("completed successfully" if success else "failed"))""",
                usage_example="python drawing_script.py",
            ),
            "advanced_automation": PythonTemplate(
                name="advanced_automation",
                description="Advanced automation with error handling and performance monitoring",
                parameters=["operations", "error_handling", "performance_tracking"],
                imports=["advanced"],
                code_template="""#!/usr/bin/env python3
\"\"\"
{description}
Generated by Master AutoCAD Coder - Advanced Template
\"\"\"

{imports}

class AutoCADAutomation:
    \"\"\"Advanced AutoCAD automation class with monitoring and error handling.\"\"\"
    def __init__(self):
        self.acad = None
        self.performance_metrics = {{}}
        self.error_count = 0
    def initialize_connection(self) -> bool:
        \"\"\"Initialize AutoCAD connection with validation.\"\"\"
        try:
            self.acad = Autocad()
            status = self.acad.get_connection_status()
            if not status['connected']:
                logging.error("AutoCAD connection failed")
                return False
            logging.info(f"Connected to AutoCAD {{status.get('autocad_version', 'Unknown')}}")
            return True
        except Exception as e:
            logging.error(f"Connection initialization failed: {{e}}")
            return False
    @handle_autocad_errors
    @monitor_performance
    def execute_operations(self) -> Dict[str, Any]:
        \"\"\"Execute main automation operations.\"\"\"
        results = {{
            'operations_completed': 0,
            'operations_failed': 0,
            'details': []
        }}
        try:
            # {operation_description}
            {main_operations}
            results['operations_completed'] += 1
            results['details'].append('Main operations completed successfully')
        except Exception as e:
            results['operations_failed'] += 1
            results['details'].append(f'Operation failed: {{str(e)}}')
            logging.error(f"Operation error: {{e}}")
        return results
    def generate_report(self, results: Dict[str, Any]) -> str:
        \"\"\"Generate execution report.\"\"\"
        report = [
            "=== AutoCAD Automation Report ===",
            f"Operations Completed: {{results['operations_completed']}}",
            f"Operations Failed: {{results['operations_failed']}}",
            f"Error Count: {{self.error_count}}",
            "",
            "Performance Metrics:",
        ]
        # Add performance metrics
        metrics = self.acad.get_performance_metrics() if self.acad else {{}}
        for key, value in metrics.items():
            report.append(f"  {{key}}: {{value}}")
        report.extend(["", "Operation Details:"])
        for detail in results['details']:
            report.append(f"  - {{detail}}")
        return "\\n".join(report)

def main():
    \"\"\"Main execution function.\"\"\"
    automation = AutoCADAutomation()
    # Initialize connection
    if not automation.initialize_connection():
        return False
    # Execute operations
    results = automation.execute_operations()
    # Generate and display report
    report = automation.generate_report(results)
    print(report)
    # Log report to file
    with open('automation_report.txt', 'w') as f:
        f.write(report)
    return results['operations_failed'] == 0

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('autocad_automation.log'),
            logging.StreamHandler()
        ]
    )
    success = main()
    exit(0 if success else 1)""",
                usage_example="python advanced_automation.py",
            ),
            "batch_processing": PythonTemplate(
                name="batch_processing",
                description="Batch processing of multiple files or operations",
                parameters=["file_patterns", "operations", "parallel_processing"],
                imports=["batch_processing"],
                code_template="""#!/usr/bin/env python3
\"\"\"
{description}
Generated by Master AutoCAD Coder - Batch Processing Template
\"\"\"

{imports}

class BatchProcessor:
    \"\"\"Handles batch processing of AutoCAD operations.\"\"\"
    def __init__(self, max_workers: int = 4):
        self.acad = None
        self.max_workers = max_workers
        self.processed_count = 0
        self.failed_count = 0
        self.results = []
    def initialize_autocad(self) -> bool:
        \"\"\"Initialize AutoCAD connection.\"\"\"
        try:
            self.acad = Autocad()
            status = self.acad.get_connection_status()
            return status['connected']
        except Exception as e:
            logging.error(f"AutoCAD initialization failed: {{e}}")
            return False
    def process_single_item(self, item: Any) -> Dict[str, Any]:
        \"\"\"Process a single item in the batch.\"\"\"
        result = {{
            'item': str(item),
            'success': False,
            'message': '',
            'processing_time': 0
        }}
        import time
        start_time = time.time()
        try:
            # {single_item_processing}
            {item_operations}
            result['success'] = True
            result['message'] = 'Processed successfully'
            self.processed_count += 1
        except Exception as e:
            result['message'] = f'Processing failed: {{str(e)}}'
            self.failed_count += 1
            logging.error(f"Failed to process {{item}}: {{e}}")
        result['processing_time'] = time.time() - start_time
        return result
    def process_batch(self, items: List[Any], parallel: bool = False) -> List[Dict[str, Any]]:
        \"\"\"Process multiple items in batch.\"\"\"
        logging.info(f"Starting batch processing of {{len(items)}} items")
        if parallel and len(items) > 1:
            # Parallel processing
            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                self.results = list(executor.map(self.process_single_item, items))
        else:
            # Sequential processing
            self.results = []
            for i, item in enumerate(items, 1):
                logging.info(f"Processing item {{i}}/{{len(items)}}: {{item}}")
                result = self.process_single_item(item)
                self.results.append(result)
                # Progress update
                if i % 10 == 0:
                    logging.info(f"Progress: {{i}}/{{len(items)}} items processed")
        logging.info(
            f"Batch processing complete. Success: {{self.processed_count}}, "
            f"Failed: {{self.failed_count}}"
        )
        return self.results
    def generate_summary(self) -> Dict[str, Any]:
        \"\"\"Generate processing summary.\"\"\"
        total_time = sum(r['processing_time'] for r in self.results)
        avg_time = total_time / len(self.results) if self.results else 0
        return {{
            'total_items': len(self.results),
            'processed_successfully': self.processed_count,
            'failed_items': self.failed_count,
            'success_rate': (self.processed_count / len(self.results) * 100) if self.results else 0,
            'total_processing_time': total_time,
            'average_processing_time': avg_time,
            'failed_items_list': [r['item'] for r in self.results if not r['success']]
        }}

def main():
    \"\"\"Main execution function.\"\"\"
    # Initialize batch processor
    processor = BatchProcessor(max_workers=4)
    if not processor.initialize_autocad():
        logging.error("Failed to initialize AutoCAD")
        return False
    # Define items to process
    items = {items_to_process}
    if not items:
        logging.warning("No items to process")
        return True
    # Process batch
    results = processor.process_batch(items, parallel={parallel_processing})
    # Generate and display summary
    summary = processor.generate_summary()
    print("\\n=== Batch Processing Summary ===")
    print(f"Total Items: {{summary['total_items']}}")
    print(f"Successfully Processed: {{summary['processed_successfully']}}")
    print(f"Failed: {{summary['failed_items']}}")
    print(f"Success Rate: {{summary['success_rate']:.1f}}%")
    print(f"Total Time: {{summary['total_processing_time']:.2f}} seconds")
    print(f"Average Time per Item: {{summary['average_processing_time']:.2f}} seconds")
    if summary['failed_items_list']:
        print("\\nFailed Items:")
        for item in summary['failed_items_list']:
            print(f"  - {{item}}")
    # Save detailed results
    with open('batch_results.json', 'w') as f:
        json.dump({{
            'summary': summary,
            'detailed_results': results
        }}, f, indent=2)
    return summary['failed_items'] == 0

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    success = main()
    exit(0 if success else 1)""",
                usage_example="python batch_processor.py",
            ),
            "data_integration": PythonTemplate(
                name="data_integration",
                description="Integration with Excel, CSV, and database sources",
                parameters=["data_source", "data_operations", "output_format"],
                imports=["data_processing"],
                code_template="""#!/usr/bin/env python3
\"\"\"
{description}
Generated by Master AutoCAD Coder - Data Integration Template
\"\"\"

{imports}

class DataIntegrator:
    \"\"\"Handles data integration between AutoCAD and external sources.\"\"\"
    def __init__(self):
        self.acad = None
        self.data_cache = {{}}
    def initialize_autocad(self) -> bool:
        \"\"\"Initialize AutoCAD connection.\"\"\"
        try:
            self.acad = Autocad()
            return self.acad.get_connection_status()['connected']
        except Exception as e:
            logging.error(f"AutoCAD initialization failed: {{e}}")
            return False
    def load_data_from_excel(self, file_path: str, sheet_name: str = None) -> pd.DataFrame:
        \"\"\"Load data from Excel file.\"\"\"
        try:
            if sheet_name:
                df = pd.read_excel(file_path, sheet_name=sheet_name)
            else:
                df = pd.read_excel(file_path)
            logging.info(f"Loaded {{len(df)}} rows from {{file_path}}")
            return df
        except Exception as e:
            logging.error(f"Failed to load Excel file {{file_path}}: {{e}}")
            return pd.DataFrame()
    def load_data_from_csv(self, file_path: str) -> pd.DataFrame:
        \"\"\"Load data from CSV file.\"\"\"
        try:
            df = pd.read_csv(file_path)
            logging.info(f"Loaded {{len(df)}} rows from {{file_path}}")
            return df
        except Exception as e:
            logging.error(f"Failed to load CSV file {{file_path}}: {{e}}")
            return pd.DataFrame()
    def extract_autocad_data(self) -> pd.DataFrame:
        \"\"\"Extract data from current AutoCAD drawing.\"\"\"
        data = []
        try:
            # {data_extraction_logic}
            {extraction_operations}
            df = pd.DataFrame(data)
            logging.info(f"Extracted {{len(df)}} records from AutoCAD")
            return df
        except Exception as e:
            logging.error(f"Failed to extract AutoCAD data: {{e}}")
            return pd.DataFrame()
    def process_data(self, df: pd.DataFrame) -> pd.DataFrame:
        \"\"\"Process and transform data.\"\"\"
        try:
            # {data_processing_logic}
            {processing_operations}
            logging.info(f"Processed data: {{len(df)}} records")
            return df
        except Exception as e:
            logging.error(f"Data processing failed: {{e}}")
            return df
    def create_autocad_entities(self, df: pd.DataFrame) -> Dict[str, Any]:
        \"\"\"Create AutoCAD entities from processed data.\"\"\"
        results = {{
            'entities_created': 0,
            'entities_failed': 0,
            'details': []
        }}
        for index, row in df.iterrows():
            try:
                # {entity_creation_logic}
                {creation_operations}
                results['entities_created'] += 1
            except Exception as e:
                results['entities_failed'] += 1
                results['details'].append(f"Row {{index}}: {{str(e)}}")
                logging.error(f"Failed to create entity for row {{index}}: {{e}}")
        return results
    def export_results(self, df: pd.DataFrame, output_path: str, format_type: str = 'excel'):
        \"\"\"Export results to file.\"\"\"
        try:
            if format_type.lower() == 'excel':
                df.to_excel(output_path, index=False)
            elif format_type.lower() == 'csv':
                df.to_csv(output_path, index=False)
            else:
                df.to_json(output_path, orient='records', indent=2)
            logging.info(f"Results exported to {{output_path}}")
        except Exception as e:
            logging.error(f"Failed to export results: {{e}}")

def main():
    \"\"\"Main execution function.\"\"\"
    integrator = DataIntegrator()
    # Initialize AutoCAD
    if not integrator.initialize_autocad():
        return False
    # Load external data
    data_file = "{data_source_path}"
    if data_file.endswith('.xlsx') or data_file.endswith('.xls'):
        df = integrator.load_data_from_excel(data_file)
    elif data_file.endswith('.csv'):
        df = integrator.load_data_from_csv(data_file)
    else:
        logging.error(f"Unsupported file format: {{data_file}}")
        return False
    if df.empty:
        logging.error("No data loaded")
        return False
    # Process data
    processed_df = integrator.process_data(df)
    # Create AutoCAD entities
    creation_results = integrator.create_autocad_entities(processed_df)
    # Export results
    output_file = "integration_results.xlsx"
    integrator.export_results(processed_df, output_file)
    # Display summary
    print("\\n=== Data Integration Summary ===")
    print(f"Data Source: {{data_file}}")
    print(f"Records Processed: {{len(processed_df)}}")
    print(f"Entities Created: {{creation_results['entities_created']}}")
    print(f"Creation Failures: {{creation_results['entities_failed']}}")
    print(f"Results Exported: {{output_file}}")
    return creation_results['entities_failed'] == 0

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    success = main()
    exit(0 if success else 1)""",
                usage_example="python data_integrator.py",
            ),
        }

    def _initialize_patterns(self) -> dict[str, dict[str, Any]]:
        """Initialize pattern recognition for code generation."""
        return {
            "drawing_operations": {
                "keywords": ["draw", "create", "make", "add"],
                "entities": {
                    "line": "acad.model.AddLine",
                    "circle": "acad.model.AddCircle",
                    "polyline": "acad.model.AddPolyline",
                    "text": "acad.model.AddText",
                    "block": "acad.model.InsertBlock",
                },
                "template": "basic_drawing",
            },
            "data_operations": {
                "keywords": ["import", "export", "excel", "csv", "data", "database"],
                "operations": ["load", "process", "transform", "save"],
                "template": "data_integration",
            },
            "batch_operations": {
                "keywords": ["batch", "multiple", "process", "iterate", "files"],
                "operations": ["parallel", "sequential", "bulk"],
                "template": "batch_processing",
            },
            "automation_workflows": {
                "keywords": ["automate", "workflow", "process", "advanced"],
                "features": ["error_handling", "monitoring", "reporting"],
                "template": "advanced_automation",
            },
        }

    def generate_code(
        self, description: str, complexity: str = "basic", template_type: str = None
    ) -> dict[str, Any]:
        """Generate Python code from natural language description."""
        # Parse the description
        parsed = self._parse_description(description)

        # Determine template type if not specified
        if not template_type:
            template_type = self._determine_template_type(parsed, complexity)

        # Generate code using appropriate template
        if template_type in self.templates:
            return self._generate_from_template(template_type, parsed, complexity)
        else:
            return self._generate_custom_code(parsed, complexity)

    def _parse_description(self, description: str) -> dict[str, Any]:
        """Parse natural language description into structured data."""
        desc_lower = description.lower()

        # Identify operation types
        operations = []
        for pattern_name, pattern_info in self.patterns.items():
            if any(keyword in desc_lower for keyword in pattern_info["keywords"]):
                operations.append(pattern_name.replace("_operations", ""))

        # Extract entities and objects
        entities = []
        entity_keywords = [
            "line",
            "circle",
            "polyline",
            "text",
            "block",
            "dimension",
        ]
        for entity in entity_keywords:
            if entity in desc_lower:
                entities.append(entity)

        # Extract file references
        file_refs = re.findall(r"\\b\\w+\\.(?:xlsx?|csv|json|txt)\\b", description)

        # Extract numbers and coordinates
        numbers = re.findall(r"\\b\\d+(?:\\.\\d+)?\\b", description)
        coordinates = re.findall(
            r"\\(\\s*(-?\\d+(?:\\.\\d+)?)\\s*,\\s*(-?\\d+(?:\\.\\d+)?)\\s*(?:,\\s*(-?\\d+(?:\\.\\d+)?))?\\s*\\)",
            description,
        )

        # Determine complexity indicators
        complexity_indicators = {
            "basic": ["simple", "basic", "easy"],
            "intermediate": ["moderate", "several", "multiple"],
            "advanced": ["complex", "advanced", "sophisticated", "batch", "automated"],
        }

        detected_complexity = "basic"
        for level, indicators in complexity_indicators.items():
            if any(indicator in desc_lower for indicator in indicators):
                detected_complexity = level
                break

        return {
            "operations": operations,
            "entities": entities,
            "file_references": file_refs,
            "numbers": [float(n) for n in numbers],
            "coordinates": [
                [float(x) if x else 0 for x in coord] for coord in coordinates
            ],
            "complexity": detected_complexity,
            "description": description,
            "requires_excel": "excel" in desc_lower
            or any(f.endswith((".xlsx", ".xls")) for f in file_refs),
            "requires_batch": "batch" in desc_lower or "multiple" in desc_lower,
            "requires_data": any(
                word in desc_lower for word in ["import", "export", "data", "csv"]
            ),
        }

    def _determine_template_type(
        self, parsed: dict[str, Any], complexity: str
    ) -> str:
        """Determine the most appropriate template type."""
        # Priority-based template selection
        if parsed["requires_data"] or parsed["requires_excel"]:
            return "data_integration"
        elif parsed["requires_batch"] or len(parsed["entities"]) > 1:
            return "batch_processing"
        elif complexity == "advanced" or "automation" in parsed["operations"]:
            return "advanced_automation"
        else:
            return "basic_drawing"

    def _generate_from_template(
        self, template_type: str, parsed: dict[str, Any], complexity: str
    ) -> dict[str, Any]:
        """Generate code from a specific template."""
        template = self.templates[template_type]

        # Prepare template variables
        variables = self._prepare_template_variables(
            template_type, parsed, complexity
        )

        # Generate imports
        import_type = self._determine_import_type(template_type, parsed)
        imports = "\\n".join(self.common_imports[import_type])

        # Format the template
        try:
            code = template.code_template.format(imports=imports, **variables)

            return {
                "code": code,
                "language": "python",
                "template_type": template_type,
                "description": template.description,
                "usage_example": template.usage_example,
                "complexity": complexity,
                "requirements": self._get_requirements(template_type, parsed),
                "notes": self._generate_usage_notes(template_type, parsed),
            }

        except KeyError as e:
            return {
                "error": f"Template formatting error: missing variable {e}",
                "template_type": template_type,
            }

    def _prepare_template_variables(
        self, template_type: str, parsed: dict[str, Any], complexity: str
    ) -> dict[str, Any]:
        """Prepare variables for template formatting."""
        variables = {
            "description": parsed["description"],
            "operation_description": self._generate_operation_description(parsed),
        }

        if template_type == "basic_drawing":
            variables.update(
                {
                    "main_code": self._generate_drawing_operations(parsed),
                }
            )

        elif template_type == "advanced_automation":
            variables.update(
                {
                    "main_operations": self._generate_advanced_operations(parsed),
                }
            )

        elif template_type == "batch_processing":
            variables.update(
                {
                    "single_item_processing": "Process individual item (file, entity, etc.)",
                    "item_operations": self._generate_batch_item_operations(parsed),
                    "items_to_process": self._generate_items_list(parsed),
                    "parallel_processing": "True"
                    if complexity == "advanced"
                    else "False",
                }
            )

        elif template_type == "data_integration":
            variables.update(
                {
                    "data_source_path": (
                        parsed["file_references"][0]
                        if parsed["file_references"]
                        else "data.xlsx"
                    ),
                    "data_extraction_logic": "Extract relevant data from AutoCAD entities",
                    "extraction_operations": self._generate_extraction_operations(
                        parsed
                    ),
                    "data_processing_logic": "Transform and validate data",
                    "processing_operations": self._generate_processing_operations(
                        parsed
                    ),
                    "entity_creation_logic": "Create AutoCAD entities from data",
                    "creation_operations": self._generate_creation_operations(parsed),
                }
            )

        return variables

    def _generate_operation_description(self, parsed: dict[str, Any]) -> str:
        """Generate operation description for comments."""
        if parsed["entities"]:
            return f"Create {', '.join(parsed['entities'])} entities in AutoCAD"
        elif parsed["requires_data"]:
            return "Process data and integrate with AutoCAD"
        elif parsed["requires_batch"]:
            return "Batch process multiple items"
        else:
            return "Execute AutoCAD automation operations"

    def _generate_drawing_operations(self, parsed: dict[str, Any]) -> str:
        """Generate drawing operation code."""
        operations = []

        for entity in parsed["entities"]:
            if entity == "line":
                operations.append(
                    """        # Create line
        start_point = [0, 0, 0]  # Modify coordinates as needed
        end_point = [100, 100, 0]
        line = acad.model.AddLine(start_point, end_point)
        logging.info(f"Created line from {start_point} to {end_point}")"""
                )

            elif entity == "circle":
                operations.append(
                    """        # Create circle
        center_point = [50, 50, 0]  # Modify coordinates as needed
        radius = 25
        circle = acad.model.AddCircle(center_point, radius)
        logging.info(f"Created circle at {center_point} with radius {radius}")"""
                )

            elif entity == "text":
                operations.append(
                    """        # Create text
        text_point = [0, 0, 0]  # Modify coordinates as needed
        text_string = "Sample Text"  # Modify text as needed
        height = 2.5
        text = acad.model.AddText(text_string, text_point, height)
        logging.info(f"Created text '{text_string}' at {text_point}")"""
                )

        if not operations:
            operations.append(
                """        # Add your drawing operations here
        # Example: line = acad.model.AddLine([0, 0, 0], [100, 100, 0])
        logging.info("Drawing operations completed")"""
            )

        return "\\n".join(operations)

    def _generate_advanced_operations(self, parsed: dict[str, Any]) -> str:
        """Generate advanced operation code with error handling."""
        return """            # Execute main automation operations
            logging.info("Starting advanced automation operations")
            # Add your specific operations here
            # Example operations:
            # entity = self.acad.model.AddLine([0, 0, 0], [100, 100, 0])
            # self.acad.doc.SendCommand("ZOOM\\\\nEXTENTS\\\\n")
            logging.info("Advanced operations completed successfully")"""

    def _generate_batch_item_operations(self, parsed: dict[str, Any]) -> str:
        """Generate batch item processing operations."""
        if parsed["requires_data"]:
            return """            # Process data file
            if isinstance(item, str) and Path(item).exists():
                # Process file
                logging.info(f"Processing file: {item}")
                # Add file processing logic here
            else:
                # Process data item
                logging.info(f"Processing data item: {item}")
                # Add data processing logic here"""
        else:
            return """            # Process individual item
            logging.info(f"Processing item: {item}")
            # Add your item processing logic here
            # Example: entity operations, file processing, etc."""

    def _generate_items_list(self, parsed: dict[str, Any]) -> str:
        """Generate items list for batch processing."""
        if parsed["file_references"]:
            return f"[{', '.join(repr(ref) for ref in parsed['file_references'])}]"
        else:
            return "[]  # Define your items to process here"

    def _generate_extraction_operations(self, parsed: dict[str, Any]) -> str:
        """Generate data extraction operations."""
        return """            # Extract data from AutoCAD entities
            # Example: Get all lines and their properties
            # for entity in acad.model:
            #     if entity.ObjectName == 'AcDbLine':
            #         data.append({
            #             'type': 'Line',
            #             'start': entity.StartPoint,
            #             'end': entity.EndPoint,
            #             'length': entity.Length
            #         })"""

    def _generate_processing_operations(self, parsed: dict[str, Any]) -> str:
        """Generate data processing operations."""
        return """            # Process and transform data
            # Example: Add calculated columns, filter data, etc.
            # df['calculated_field'] = df['value1'] + df['value2']
            # df = df[df['length'] > 10]  # Filter condition"""

    def _generate_creation_operations(self, parsed: dict[str, Any]) -> str:
        """Generate entity creation operations."""
        return """                # Create AutoCAD entity from data row
                # Example: Create line from row data
                # start_pt = [row['x1'], row['y1'], 0]
                # end_pt = [row['x2'], row['y2'], 0]
                # line = self.acad.model.AddLine(start_pt, end_pt)"""

    def _determine_import_type(
        self, template_type: str, parsed: dict[str, Any]
    ) -> str:
        """Determine which import set to use."""
        if template_type == "data_integration" or parsed["requires_excel"]:
            return (
                "excel_integration" if parsed["requires_excel"] else "data_processing"
            )
        elif template_type == "batch_processing":
            return "batch_processing"
        elif template_type == "advanced_automation":
            return "advanced"
        else:
            return "basic"

    def _get_requirements(
        self, template_type: str, parsed: dict[str, Any]
    ) -> list[str]:
        """Get requirements list for the generated code."""
        requirements = ["AutoCAD 2025 or later", "Enhanced AutoCAD wrapper"]

        if template_type == "data_integration" or parsed["requires_excel"]:
            requirements.extend(["pandas", "openpyxl"])

        if template_type == "batch_processing":
            requirements.append("concurrent.futures (built-in)")

        if parsed["requires_data"]:
            requirements.extend(["numpy", "pandas"])

        return requirements

    def _generate_usage_notes(
        self, template_type: str, parsed: dict[str, Any]
    ) -> list[str]:
        """Generate usage notes for the code."""
        notes = [
            "Ensure AutoCAD is running before executing the script",
            "Modify coordinates and parameters as needed for your specific use case",
            "Check the log files for detailed execution information",
        ]

        if template_type == "data_integration":
            notes.extend(
                [
                    "Update data source path and column names",
                    "Verify Excel/CSV file format matches expected structure",
                ]
            )

        if template_type == "batch_processing":
            notes.extend(
                [
                    "Adjust max_workers parameter based on system capabilities",
                    "Monitor system resources during parallel processing",
                ]
            )

        if template_type == "advanced_automation":
            notes.extend(
                [
                    "Review error handling and add specific exception handling",
                    "Customize performance monitoring parameters",
                ]
            )

        return notes

    def _generate_custom_code(
        self, parsed: dict[str, Any], complexity: str
    ) -> dict[str, Any]:
        """Generate custom code when no template matches."""
        import_type = "advanced" if complexity == "advanced" else "basic"
        imports = "\\n".join(self.common_imports[import_type])

        code = f"""#!/usr/bin/env python3
\\\"\\\"\\\"
{parsed['description']}
Generated by Master AutoCAD Coder - Custom Template
\\\"\\\"\\\"

{imports}

def main():
    \\\"\\\"\\\"Main execution function.\\\"\\\"\\\"
    # Initialize AutoCAD connection
    acad = Autocad()
    # Verify connection
    status = acad.get_connection_status()
    if not status['connected']:
        logging.error("Failed to connect to AutoCAD")
        return False
    logging.info(f"Connected to AutoCAD {{status.get('autocad_version', 'Unknown')}}")
    try:
        # {self._generate_operation_description(parsed)}
        # TODO: Add your specific automation logic here
        logging.info("Custom automation completed successfully")
        return True
    except Exception as e:
        logging.error(f"Automation failed: {{e}}")
        return False

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    success = main()
    print("Automation " + ("completed successfully" if success else "failed"))"""

        return {
            "code": code,
            "language": "python",
            "template_type": "custom",
            "description": f"Custom Python script for {parsed['description']}",
            "usage_example": "python custom_automation.py",
            "complexity": complexity,
            "requirements": ["AutoCAD 2025 or later", "Enhanced AutoCAD wrapper"],
            "notes": [
                "This is a custom template - add specific logic as needed",
                "Refer to enhanced AutoCAD wrapper documentation",
                "Test thoroughly before production use",
            ],
        }

    def get_available_templates(self) -> dict[str, Any]:
        """Get information about available templates."""
        return {
            "templates": {
                name: {
                    "name": template.name,
                    "description": template.description,
                    "parameters": template.parameters,
                    "usage_example": template.usage_example,
                }
                for name, template in self.templates.items()
            },
            "import_types": list(self.common_imports.keys()),
            "supported_patterns": list(self.patterns.keys()),
        }

    def validate_code(self, code: str) -> dict[str, Any]:
        """Basic Python code validation."""
        issues = []
        suggestions = []

        # Check for basic Python syntax
        try:
            compile(code, "<string>", "exec")
        except SyntaxError as e:
            issues.append(f"Syntax error: {e}")

        # Check for required imports
        if "from src.enhanced_autocad" not in code:
            issues.append("Missing enhanced AutoCAD import")
            suggestions.append(
                "Add: from src.enhanced_autocad.compatibility_layer import Autocad"
            )

        # Check for logging setup
        if "import logging" not in code:
            suggestions.append("Consider adding logging for better debugging")

        # Check for error handling
        if "try:" not in code or "except" not in code:
            suggestions.append("Add try/except blocks for robust error handling")

        # Check for main function pattern
        if 'if __name__ == "__main__":' not in code:
            suggestions.append(
                "Add main execution block: if __name__ == '__main__':"
            )

        return {
            "valid": len(issues) == 0,
            "issues": issues,
            "suggestions": suggestions,
            "quality_score": max(0, 100 - len(issues) * 20 - len(suggestions) * 5),
        }
